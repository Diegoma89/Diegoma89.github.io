<!DOCTYPE html>
<html>
<script src='https://d3js.org/d3.v5.min.js'></script>
<style>
rect {fill: lightblue; stroke: black;}
path.fade{ display: none;}
.link line {stroke: black;}
.node circle {stroke: black; fill: White;}
.node text {text-anchor: middle; font-size: 20px}
#tooltip{
  opacity: 0;
  position: absolute;
  text-align: center;
  width: 60px;
  height: 40px;
  background: white;
  border: 0px;
}
</style>
<body onload='init()'>

<div id="tooltip"></div>

<script>


function rotate(angle){
    if(angle > Math.PI) {
        return "rotate(180)"; }
    else { return ""; }
    };

function DoSome(){
  d3.select("svg").selectAll("circle").style("fill", "green");
}


async function init() {
  const winrateciv = await d3.csv('https://raw.githubusercontent.com/Diegoma89/diegoma89.github.io/master/winrate_civ.csv');
  const data = await d3.csv('https://raw.githubusercontent.com/Diegoma89/diegoma89.github.io/master/data_matches_formatted_reduced.csv');
  const pairMatch = await d3.csv('https://raw.githubusercontent.com/Diegoma89/diegoma89.github.io/master/PairsMatches.csv');
  const pairsMatrix = await d3.csv("https://raw.githubusercontent.com/Diegoma89/diegoma89.github.io/master/PairsMatrixComplete.csv");

  var color = d3.scaleOrdinal(d3.schemeTableau10);

  civlist = winrateciv.map(function(d) {return d.civ});
  winrates = winrateciv.map(function(d) {return d.winrate});


  function updatepie(){
       console.log("remove");
       console.log(d3.event.srcElement.__data__);
       svg.selectAll("image").remove();
       svg.selectAll("path").remove();
       svg.append("g")
           .attr("transform", "translate(1100,150)")
         .selectAll("path")
         .data(pie([d3.event.srcElement.__data__.winrate, 1-d3.event.srcElement.__data__.winrate]))
         .enter()
         .append("path")
           .attr("d", arc)
           .attr("fill", function(d,i) {if(i==0) { return color(4)} else {return color(2)};})
           .attr("stroke", "black")
           .attr("stroke-width", 1);
  }


  var width = 1100;
  var height = 500;
  var margin = 75;

  var widthpie = 300;

  var svg = d3.select("body").append("svg")
      .attr("width",  width+(margin*2))
      .attr("height", height+(margin*2));

  var tooltip = d3.select("#tooltip");


  x = d3.scaleBand().domain(civlist).range([0,width-300]).padding(0.2);;
  y = d3.scaleLinear().domain([0,1]).range([height,0]);


  svg.append("g")
      .attr("transform", "translate("+margin+","+margin+")")
    .selectAll('rect')
    .data(winrateciv)
    .enter()
    .append('rect')
      .attr('x',function(d) {return x(d.civ);})
      .attr('y',function(d) {return y(0);})
      .attr('width',x.bandwidth())
      .attr('height',0)
      .style("fill", function(d, i) {return color(i);});

  svg.append("g")
      .attr("transform", "translate("+margin+","+margin+")")
      .call(d3.axisLeft(y).tickFormat(d3.format("~%")));

  svg.append("g")
      .attr("transform", "translate("+margin+","+(height+margin)+")")
      .call(d3.axisBottom(x))
      .selectAll("text")
      .attr("y", 0)
      .attr("x", 9)
      .attr("dy", ".35em")
      .attr("transform", "rotate(90)")
      .style("text-anchor", "start");


  svg.selectAll("rect")
    .transition()
    .duration(1000)
    .attr("y", function(d) {return y(d.winrate);})
    .attr("height", function(d,i) {return y(1-Number(d.winrate));})



//function(d,i) {tooltip.style("opacity", 1).style("left", (d3.event.pageX)+"px").style("top", (d3.event.pageY)+"px").html(d.winrate);}

//Pie chart


var center = 150;
var inrad = 50;
var outrad = 100;
var colorinit = ['grey','darkgrey'];
//var color = ['green','red'];
var pie = d3.pie().sort(null);
var arc = d3.arc().innerRadius(inrad).outerRadius(outrad);

console.log(color);
      svg.append("g")
          .attr("transform", "translate(1100,150)")
        .selectAll("path")
        .data(pie([0.5, 0.5]))
        .enter()
        .append("path")
          .attr("d", arc)
          .attr("fill", function(d,i) {return colorinit[i];});

svg.selectAll("rect")
   .on("mouseover", updatepie);

svg.append("image")
    .attr("href", "https://vignette.wikia.nocookie.net/ageofempires/images/0/07/CivIcon-Vietnamese.png/revision/latest?cb=20191107173409")
    .attr("x", 1050)
    .attr("y", 100)
    .attr("height", "100px")
    .attr("width", "100px");

 /*start nodes
 const civ1WD = data.filter(function(d) {return d.teamcivs.includes("Britons")})
  console.log(civ1WD);

  var i;
  var PairWins = [];
  var PairMatches = [];
  var PairWinrates = [];
  var CurrCiv = "Britons";



var svg = d3.select("svg"),
width = +svg.attr("width"),
height = +svg.attr("height");

var simulation = d3.forceSimulation()
.force("link", d3.forceLink().distance(function(d) { return d.winrate;})
    .id(function(d) { return d.value;}))
.force("charge", d3.forceManyBody().strength(-300))
.force("center", d3.forceCenter(width / 2, height / 2));

console.log(civlist);

var nodes = [
{"value": "Aztecs"},
{"value": "Berbers"},
{"value": "Britons"},
{"value": "Celts"},
{"value": "Mayans"},
{"value": "Huns"}
];

console.log(nodes);


simulation.nodes(nodes);

var links = [
{"source":  "Britons", "target":  "Aztecs", "winrate": 300},
{"source": "Britons", "target":  "Berbers", "winrate": 100},
{"source": "Britons", "target":  "Celts", "winrate": 200},
{"source": "Britons", "target":  "Mayans", "winrate": 110},
{"source": "Britons", "target": "Huns", "winrate": 400},

];

simulation.force("link").links(links);

console.log(simulation);

var linksel = svg.append("g")
.attr("class", "link")
.selectAll("line").data(links).enter().append("line")

var nodesel = svg.selectAll(".node")
.data(nodes)
.enter().append("g")
.attr("class", "node")
.call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

nodesel.append("circle")
.attr("r",40);

nodesel.append("text")
.attr("transform","translate(0,6)")
.text(function (d) { return d.value; });

// replace "tick" with "end" for static layout
simulation.on("tick", ticked);

function ticked() {
linksel.attr("x1", function(d) { return d.source.x; })
    .attr("y1", function(d) { return d.source.y; })
    .attr("x2", function(d) { return d.target.x; })
    .attr("y2", function(d) { return d.target.y; });

nodesel.attr("transform", function(d) {
    return "translate(" + d.x + "," + d.y + ")";
});
}

function dragstarted(d) {
if (!d3.event.active) simulation.alphaTarget(0.3).restart();
d.fx = d.x;
d.fy = d.y;
}
function dragged(d) {
d.fx = d3.event.x;
d.fy = d3.event.y;
}
function dragended(d) {
if (!d3.event.active) simulation.alphaTarget(0);
d.fx = null;
d.fy = null;
}
 end nodes */


/* start histo combined
 const civ1WD = data.filter(function(d) {return d.teamcivs.includes("Britons")})
  console.log(civ1WD);

  var i;
  var PairWins = [];
  var PairMatches = [];
  var PairWinrates = [];
  var CurrCiv = "Britons";

  for (i = 0; i < civlist.length; i++) {
    if (civlist[i] == CurrCiv) {
      var civ2WD = civ1WD.filter(function(d) { if(d.teamcivs.indexOf(civlist[i]) != d.teamcivs.lastIndexOf(civlist[i])) {return d.teamcivs} });
    }
    else {
      var civ2WD = civ1WD.filter(function(d) {return d.teamcivs.includes(civlist[i])});
    };

    var PairWin = d3.sum(civ2WD, function(d) { return d.won });
    PairWins.push(PairWin);
    PairMatches.push(civ2WD.length);
    PairWinrates.push(PairWin/civ2WD.length)
  };


  var width = 500
  var height = 500
  var margin = 50

  x = d3.scaleBand().domain(civlist).range([0,width]);
  y = d3.scaleLinear().domain([0,1]).range([height,0]);
  d3.select('svg')
    .append("g")
      .attr("transform", "translate("+margin+","+margin+")")
    .selectAll('rect')
    .data(PairWinrates)
    .enter()
    .append('rect')
      .attr('x',function(d,i) {return x(civlist[i]);})
      .attr('y',function(d) {return y(d);})
      .attr('width',x.bandwidth())
      .attr('height',function(d) {return y(1-Number(d));})

  d3.select('svg')
    .append("g")
      .attr("transform", "translate("+margin+","+margin+")")
      .call(d3.axisLeft(y))

  d3.select('svg')
    .append("g")
      .attr("transform", "translate("+margin+","+(height+margin)+")")
      .call(d3.axisBottom(x))
      .selectAll("text")
      .attr("y", 0)
      .attr("x", 9)
      .attr("dy", ".35em")
      .attr("transform", "rotate(90)")
      .style("text-anchor", "start");

end histo combined */




/* start chordgraph

var margin      = {top: 10, right: 10, bottom: 10, left: 10};
var width       = 900 - margin.left - margin.right;
var height      = 900 - margin.top  - margin.bottom;
var innerRadius = width * .4;
var outerRadius = innerRadius * 1.05;

var svg = d3.select("body").append("svg")
    .attr("width",  width  + margin.left + margin.right)
    .attr("height", height + margin.top  + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .append("g")
    .attr("class", "chordgraph")
    .attr("transform", "translate(" + width/2 + "," + height/2 + ")");


var firstColumn = "Civ1";

//store column names
var fc = [],
    mat_size = pairsMatrix.length,
    matrix  = [];

for(var i=0; i < mat_size; i++){
    matrix.push(new Array(mat_size+1).join('0').split('').map(parseFloat));
}

for(var i=0; i < mat_size; i++){

    var j = 0;

    for(var pairm in pairsMatrix[i]){

        if(pairm != firstColumn){
            fc.push(pairm);
            matrix[i][j] = +pairsMatrix[i][pairm];
            matrix[j][i] = +pairsMatrix[i][pairm];
            j++;
        }
    }
}

var fo = fc.slice(0,mat_size);


//set color scale. More color options: https://github.com/d3/d3-scale-chromatic
var color = d3.scaleOrdinal(d3.schemeTableau10)

//d3 chord generator
var chord = d3.chord()
    .padAngle(0.01)
    .sortSubgroups(d3.descending);

//apply the matrix
var chords = chord(matrix);

//each ribbon generator
var ribbon = d3.ribbon()
    .radius(innerRadius);

//outer rim arc
var arc = d3.arc()
    .innerRadius(innerRadius)
    .outerRadius(innerRadius + 20);

//add each of the groupings for outer rim arcs
var group = svg.append("g")
    .selectAll("g")
    .data(chords.groups)
    .enter()
    .append("g");

//add each outer rim arc path
group.append("path")
    .attr("fill", function(d){ return color(d.index); })
    .attr("d", arc)
    .style("cursor", "pointer")
    .on("mouseover", function(d, i){
        ribbons.classed("fade", function(d){
            return d.source.index != i && d.target.index != i;
        });
    });
console.log(chords);
//add each ribbon
var ribbons = svg.append("g")
  .attr("fill-opacity", .5)
  .selectAll("path")
  .data(chords)
  .enter()
  .append("path")
  .attr("d", ribbon)
  .attr("fill", function(d){ return color(d.source.index); })
  .attr("stroke", "black")
  .style("stroke","Black")
  .style("stroke-width",".25px");


//add the text labels
group.append("text")
  .each(function(d){ return d.angle = (d.startAngle + d.endAngle) /2; })
  .attr("class", "text")
  .style("pointer-events","none")
  .attr("text-anchor", function(d) { if(d.angle > Math.PI) { return "end"; } else { return "start"; }})
  .attr("transform", function(d,i){
      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
             "translate(" + (outerRadius + 10) + ")" +
             (rotate(d.angle));

  })
  .text(function(d,i){
      //set the text content
      return fc[i];
  })
  .style("font-family","sans-serif")
  .style("font-size","15px");



    window.addEventListener('mouseup', (e) => {

      if(e.target.tagName == "svg");{
        ribbons.classed("fade", false)
      };
    })
end chordgraph */
}
</script>
</body>
</html>
